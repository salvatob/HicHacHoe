module Board.SimpleBoard where

import Board.Board
import Board.Symbol
import Data.List (intercalate)
import Data.Char (chr)

-- simple 3x3 Board instance
newtype SimpleBoard = SimpleBoard [[Symbol]]

instance Board SimpleBoard where
  placeS (r, c) (SimpleBoard b) s =
    SimpleBoard (replaceAt r (replaceAt c s (b !! r)) b)

  printBoard (SimpleBoard b) = do putStrLn $ showBoard b

  empty = SimpleBoard $ replicate 3 $ replicate 3 E

  getS (r, c) (SimpleBoard b) = (b !! r) !! c

  getRow i (SimpleBoard b) = b !! i

  getCol i (SimpleBoard b) = map ( !! i ) b

  getWidth (SimpleBoard b) = length $ head b
  getHeight (SimpleBoard b) = length b

  rowIndices (SimpleBoard b) = [0..(getHeight (SimpleBoard b) -1)]
  colIndices (SimpleBoard b) = [0..(getWidth (SimpleBoard b) -1)]

  allRows (SimpleBoard b) = b

  allCols b =
    [getCol j b | j <- colIndices b]

  allDiagonals (SimpleBoard b) = diagonalsTLBR b ++ diagonalsTRBL b

  nextStates s (SimpleBoard b) =
    foldl
    (\acc coords->
      if getS coords (SimpleBoard b) /= E then acc
      else SimpleBoard (replaceAtMatrix coords s b) : acc)
    []
    coordinates
    where
      coordinates = [(i,j) | i <- rowIndices (SimpleBoard b), j <- colIndices (SimpleBoard b)]

  isFull (SimpleBoard b) = all (notElem E) b



showBoard :: [[Symbol]] -> String
showBoard b =
  unlines $
    showFirstRow w :
    zipWith showRow  [1..] b
  where
    bo = SimpleBoard b
    w = getWidth bo

showFirstRow :: Int -> String
showFirstRow len = " " ++ intercalate "" (map (\c -> " " ++ [chr c]) [97..(96+len)])
showRow :: Int -> [Symbol] -> String
showRow idx row = show idx ++ " " ++ intercalate "|" (map renderSymbol row)


-- logic for retreiving grid diagonals was generated by chatGPT

-- All top-left → bottom-right diagonals
diagonalsTLBR :: [[a]] -> [[a]]
diagonalsTLBR matrix =
    let n = length matrix
        m = if null matrix then 0 else length (head matrix)
        -- generate diagonals starting on first row
        diagFromRow r = [matrix !! (r+k) !! k | k <- [0..min (n-r-1) (m-1)]]
        -- generate diagonals starting on first column
        diagFromCol c = [matrix !! k !! (c+k) | k <- [0..min (n-1) (m-c-1)]]
    in [diagFromRow r | r <- [0..n-1]] ++ [diagFromCol c | c <- [1..m-1]]

-- All top-right → bottom-left diagonals
diagonalsTRBL :: [[a]] -> [[a]]
diagonalsTRBL matrix =
    let n = length matrix
        m = if null matrix then 0 else length (head matrix)
        diagFromRow r = [matrix !! (r+k) !! (m-1-k) | k <- [0..min (n-r-1) (m-1)]]
        diagFromCol c = [matrix !! k !! (c-k) | k <- [0..min (n-1) c]]
    in [diagFromRow r | r <- [0..n-1]] ++ [diagFromCol c | c <- [m-2,m-3..0]]
