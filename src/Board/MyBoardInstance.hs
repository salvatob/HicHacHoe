module Board.MyBoardInstance where

import Board.Board
import Board.Symbol
import Data.List (intercalate)
import Data.Char (chr)

newtype MyBoard = MyBoard [[Symbol]]

instance Board MyBoard where
  printBoard b = do putStrLn $ showBoard b

  empty r c = MyBoard $ replicate r $ replicate c E

  placeS (r, c) (MyBoard b) s =
    MyBoard (replaceAt r (replaceAt c s (b !! r)) b)

  getS (r, c) (MyBoard b) = (b !! r) !! c

  getRow i (MyBoard b) = b !! i

  getCol i (MyBoard b) = map ( !! i ) b

  getWidth (MyBoard b) = length $ head b
  getHeight (MyBoard b) = length b

  rowIndices (MyBoard b) = [0..(getHeight (MyBoard b) -1)]
  colIndices (MyBoard b) = [0..(getWidth (MyBoard b) -1)]

  allRows (MyBoard b) = b

  allCols b =
    [getCol j b | j <- colIndices b]

  allDiagonals (MyBoard b) = diagonalsTLBR b ++ diagonalsTRBL b

  nextStates s (MyBoard b) =
    foldl
    (\acc coords->
      if getS coords (MyBoard b) /= E then acc
      else MyBoard (replaceAtMatrix coords s b) : acc)
    []
    coordinates
    where
      coordinates = [(i,j) | i <- rowIndices (MyBoard b), j <- colIndices (MyBoard b)]

  isFull (MyBoard b) = all (notElem E) b


replaceAt :: Int -> a -> [a] -> [a]
replaceAt i val xs =
  take i xs ++ [val] ++ drop (i+1) xs

replaceAtMatrix :: (Int, Int) -> a -> [[a]] -> [[a]]
replaceAtMatrix (i, j) val xs = replaceAt i (replaceAt j val (xs !! i)) xs

-- showMyBoard :: MyBoard -> String
-- showMyBoard (MyBoard b) = unlines $ map (map $ head . renderSymbol) b

showBoard :: MyBoard -> String
showBoard (MyBoard b) =
  unlines $
    showFirstRow w :
    zipWith showRow  [1..] b
  where
    bo = MyBoard b
    w = getWidth bo

showFirstRow :: Int -> String
showFirstRow len = " " ++ intercalate "" (map (\c -> " " ++ [chr c]) [97..(96+len)])
showRow :: Int -> [Symbol] -> String
showRow idx row = show idx ++ " " ++ intercalate "|" (map renderSymbol row)


-- logic for retreiving grid diagonals was generated by chatGPT

-- All top-left → bottom-right diagonals
diagonalsTLBR :: [[a]] -> [[a]]
diagonalsTLBR matrix =
    let n = length matrix
        m = if null matrix then 0 else length (head matrix)
        -- generate diagonals starting on first row
        diagFromRow r = [matrix !! (r+k) !! k | k <- [0..min (n-r-1) (m-1)]]
        -- generate diagonals starting on first column
        diagFromCol c = [matrix !! k !! (c+k) | k <- [0..min (n-1) (m-c-1)]]
    in [diagFromRow r | r <- [0..n-1]] ++ [diagFromCol c | c <- [1..m-1]]

-- All top-right → bottom-left diagonals
diagonalsTRBL :: [[a]] -> [[a]]
diagonalsTRBL matrix =
    let n = length matrix
        m = if null matrix then 0 else length (head matrix)
        diagFromRow r = [matrix !! (r+k) !! (m-1-k) | k <- [0..min (n-r-1) (m-1)]]
        diagFromCol c = [matrix !! k !! (c-k) | k <- [0..min (n-1) c]]
    in [diagFromRow r | r <- [0..n-1]] ++ [diagFromCol c | c <- [m-2,m-3..0]]
